{"version":3,"sources":["index.js"],"names":["THREE","require","colors","sprite","TextureLoader","load","getRandomNumber","Math","random","getRandomPoints","positions","Array","fill","forEach","push","getRandomColor","Color","parseInt","length","getRandomColors","r","g","b","Scene","points","pointsData","setHoverDescription","useThree","scene","camera","aspect","ref","useRef","geometryRef","positionsArray","useMemo","Float32Array","nPoints","colorsArray","useSpring","pointsSpring","colorsSpring","setSpring","useEffect","useFrame","getValue","v","i","value","current","attributes","position","array","color","needsUpdate","fov","near","far","set","updateProjectionMatrix","background","onPointerOver","index","clientX","clientY","description","top","left","showLeft","max","hoverWidth","className","style","width","HoverDescription","onPointerOut","attach","attachObject","count","itemSize","usage","DynamicDrawUsage","size","map","transparent","alphaTest","sizeAttenuation","vertexColors","VertexColors","ReactDOM","render","useState","setPoints","setColors","animatePoints","setAnimatePoints","animateColors","setAnimateColors","toogleColorsClass","setToogleColorsClass","tooglePointsClass","setTooglePointsClass","hoverData","setHoverData","keys","d","data","type","onClick","clearInterval","interval","window","setInterval","toogleColors","tooglePoints","document","getElementById"],"mappings":"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","file":"static/js/main.2d77330f.chunk.js","sourcesContent":["import 'bootstrap/dist/css/bootstrap.css';\nimport React, { useRef, useMemo, useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { Canvas, useThree,  useFrame } from 'react-three-fiber';\nimport { useSpring } from 'react-spring-three';\nimport './index.css';\nconst THREE = require('three');\n// const d3 = require('d3');\n\n// camera settings\nconst fov = 30;\nconst near = 10;\nconst far = 100;\n// points generation\nconst nPoints = 100;\nconst randomScale = 50;\nconst pointsSize = 25;\nconst colors = ['mediumslateblue', 'indianred', 'darkseagreen'];\nconst sprite = new THREE.TextureLoader().load('textures/discNoShadow.png')\n// hover description settings\nconst hoverWidth = 150;\n\nconst getRandomNumber = () => (Math.random()-0.5)*randomScale;\n\nconst getRandomPoints = () => {\n  let positions = []\n  Array(nPoints).fill().forEach(() => {\n    positions.push(getRandomNumber(), getRandomNumber(), 0);\n  });\n  return positions;\n};\n\nconst getRandomColor = () => new THREE.Color(colors[parseInt(Math.random() * colors.length)]);\nconst getRandomColors = () => {\n  let colors = []\n  Array(nPoints).fill().forEach(() => {\n    const {r,g,b} = getRandomColor();\n    colors.push(r,g,b);\n  });\n  return colors;\n};\n\nconst HoverDescription = ({ description, top, left }) => {\n  const showLeft = Math.max(left-hoverWidth/2, 0);\n  return (\n  <div\n    className='hover-description'\n    style={{top: top, left: showLeft, width: hoverWidth}}\n  >\n    {description}\n  </div>);\n};\n\nconst Scene = ({ points, colors, pointsData, setHoverDescription }) => {\n  const { scene, camera, aspect } = useThree();\n  const ref = useRef();\n  const geometryRef = useRef();\n\n  // Initialize arrays\n  const positionsArray = useMemo(() => new Float32Array(nPoints*3), []);\n  const colorsArray = useMemo(() => new Float32Array(nPoints*3), []);\n\n  // Initialize springs\n  const [ { pointsSpring, colorsSpring }, setSpring ] = useSpring(() => ({\n    // initial position\n    pointsSpring: points,\n    colorsSpring: Array(nPoints*3).fill(1),\n  }));\n\n  // Animation effects\n  useEffect(() => {\n    setSpring({ pointsSpring: points });\n  }, [ points, setSpring ]);\n\n  useEffect(() => {\n    setSpring({ colorsSpring: colors });\n  }, [ colors, setSpring ]);\n\n  // Animate point change\n  useFrame(() => {\n    pointsSpring.getValue().forEach((v,i) => {\n      const value = (i%3) === 0 ? v*aspect : v; // consider aspect\n      geometryRef.current.attributes.position.array[i] = value;\n    });\n    colorsSpring.getValue().forEach((v,i) => {\n      geometryRef.current.attributes.color.array[i] = v;\n    })\n    geometryRef.current.attributes.position.needsUpdate = true;\n    geometryRef.current.attributes.color.needsUpdate = true;\n  });\n\n  useEffect(() => {\n    camera.fov = fov;\n    camera.near = near;\n    camera.far = far;\n    camera.position.set(0, 0, far);\n    camera.updateProjectionMatrix();\n    scene.background = new THREE.Color(0xefefef);\n  }, [ scene, camera ]);\n\n  // Events\n  const pointOver = ( { index, clientX, clientY } ) => {\n    setHoverDescription(HoverDescription({\n      description: `mouse over: ${pointsData[index]}`,\n      top: clientY,\n      left: clientX,\n    }));\n  };\n\n  const pointOut = () => {\n    setHoverDescription('');\n  };\n\n  return (\n    <mesh\n      ref={ref}\n      onPointerOver={pointOver}\n      onPointerOut={pointOut}\n    >\n      <points>\n        <bufferGeometry\n          attach='geometry'\n          ref={geometryRef}\n        >\n          <bufferAttribute\n            attachObject={['attributes', 'position']}\n            count={points.length / 3}\n            array={positionsArray}\n            itemSize={3}\n            usage={THREE.DynamicDrawUsage}\n          />\n          <bufferAttribute\n            attachObject={['attributes', 'color']}\n            count={points.length / 3}\n            array={colorsArray}\n            itemSize={3}\n            usage={THREE.DynamicDrawUsage}\n          />\n        </bufferGeometry>\n        <pointsMaterial\n          attach='material'\n          size={pointsSize}\n          map={sprite}\n          transparent={true}\n          alphaTest={0.5}\n          sizeAttenuation={false}\n          vertexColors={THREE.VertexColors}\n        />\n      </points>\n    </mesh>\n  );\n};\n\nconst App = () => {\n  const [ points, setPoints ] = useState(getRandomPoints());\n  const [ colors, setColors ] = useState(getRandomColors());\n  const [ animatePoints, setAnimatePoints ] = useState(false);\n  const [ animateColors, setAnimateColors ] = useState(false);\n  const [ toogleColorsClass, setToogleColorsClass ] = useState('light');\n  const [ tooglePointsClass, setTooglePointsClass ] = useState('light');\n  const [ hoverData, setHoverData] = useState('');\n  const pointsData = useMemo(() => [...Array(nPoints).keys()].map(d => `Points #${d}`), []);\n\n  const setHoverDescription = data => {\n    setHoverData(data)\n  };\n\n  // toogle functions\n  const tooglePoints = () => {\n    if ( !animatePoints ) {\n      const interval = window.setInterval(() => setPoints(getRandomPoints()), 1000);\n      setAnimatePoints(interval);\n      setTooglePointsClass('dark');\n    } else {\n      clearInterval(animatePoints);\n      setAnimatePoints(false);\n      setTooglePointsClass('light');\n    }\n  };\n\n  const toogleColors = () => {\n    if ( !animateColors ) {\n      const interval = window.setInterval(() => setColors(getRandomColors()), 1000);\n      setAnimateColors(interval);\n      setToogleColorsClass('dark');\n    } else {\n      clearInterval(animateColors);\n      setAnimateColors(false);\n      setToogleColorsClass('light');\n    }\n  };\n\n  return (\n    <div className='canvas-container'>\n      <Canvas>\n        <Scene\n          points={points}\n          colors={colors}\n          pointsData={pointsData}\n          setHoverDescription={setHoverDescription}\n        />\n      </Canvas>\n      {hoverData}\n      <div className='button-container'>\n        <button\n          type='button'\n          className='btn btn-light'\n          onClick={() => setColors(getRandomColors())}\n        >\n          Change colors\n        </button>\n        <button\n          type='button'\n          className={`btn btn-${toogleColorsClass}`}\n          onClick={() => toogleColors()}\n        >\n          Toogle colors\n        </button>\n        <button\n          type='button'\n          className='btn btn-light'\n          onClick={() => setPoints(getRandomPoints())}\n        >\n          Refresh\n        </button>\n        <button\n          type='button'\n          className={`btn btn-${tooglePointsClass}`}\n          onClick={() => tooglePoints()}\n        >\n          Toogle Refresh\n        </button>\n      </div>\n    </div>\n  )\n};\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}