{"version":3,"sources":["index.js"],"names":["THREE","require","colors","sprite","TextureLoader","load","getRandomNumber","Math","random","getRandomPoints","positions","Array","fill","forEach","push","getRandomColor","Color","parseInt","length","getRandomColors","r","g","b","Scene","points","useThree","scene","camera","aspect","geometryRef","useRef","positionsArray","useMemo","Float32Array","nPoints","colorsArray","useSpring","pointsSpring","colorsSpring","setSpring","useEffect","useFrame","getValue","v","i","value","current","attributes","position","array","color","needsUpdate","fov","near","far","set","updateProjectionMatrix","background","attach","ref","attachObject","count","itemSize","usage","DynamicDrawUsage","size","map","transparent","alphaTest","sizeAttenuation","vertexColors","VertexColors","ReactDOM","render","useState","setPoints","setColors","animatePoints","setAnimatePoints","animateColors","setAnimateColors","toogleColorsClass","setToogleColorsClass","tooglePointsClass","setTooglePointsClass","className","type","onClick","clearInterval","interval","window","setInterval","toogleColors","tooglePoints","document","getElementById"],"mappings":"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","file":"static/js/main.529c53aa.chunk.js","sourcesContent":["import 'bootstrap/dist/css/bootstrap.css';\nimport React, { useRef, useMemo, useState, useEffect, useCallback } from 'react';\nimport ReactDOM from 'react-dom';\nimport { Canvas, useThree,  useFrame } from 'react-three-fiber';\nimport { useSpring } from 'react-spring-three';\nimport './index.css';\nconst THREE = require('three');\n// const d3 = require('d3');\n\n// camera settings\nconst fov = 30;\nconst near = 10;\nconst far = 100;\n// points generation\nconst nPoints = 100;\nconst randomScale = 50;\nconst pointsSize = 25;\nconst colors = ['mediumslateblue', 'indianred', 'darkseagreen'];\nconst sprite = new THREE.TextureLoader().load('textures/discNoShadow.png')\n\nconst getRandomNumber = () => (Math.random()-0.5)*randomScale;\n\nconst getRandomPoints = () => {\n  let positions = []\n  Array(nPoints).fill().forEach(() => {\n    positions.push(getRandomNumber(), getRandomNumber(), 0);\n  });\n  return positions;\n};\n\nconst getRandomColor = () => new THREE.Color(colors[parseInt(Math.random() * colors.length)]);\nconst getRandomColors = () => {\n  let colors = []\n  Array(nPoints).fill().forEach(() => {\n    const {r,g,b} = getRandomColor();\n    colors.push(r,g,b);\n  });\n  return colors;\n};\n\nconst Scene = ({ points, colors }) => {\n  const { scene, camera, aspect } = useThree();\n  const geometryRef = useRef();\n\n  // Initialize arrays\n  const positionsArray = useMemo(() => new Float32Array(nPoints*3), []);\n  const colorsArray = useMemo(() => new Float32Array(nPoints*3), []);\n\n  // Initialize springs\n  const [ { pointsSpring, colorsSpring }, setSpring ] = useSpring(() => ({\n    // initial position\n    pointsSpring: new Array(nPoints*3).fill(0),\n    colorsSpring: new Array(nPoints*3).fill(1)\n  }));\n\n  // Animation effects\n  useEffect(() => {\n    setSpring({ pointsSpring: points });\n  }, [ points, setSpring ]);\n\n  useEffect(() => {\n    setSpring({ colorsSpring: colors });\n  }, [ colors, setSpring ]);\n\n  // Animate point change\n  useFrame(() => {\n    pointsSpring.getValue().forEach((v,i) => {\n      const value = (i%3) === 0 ? v*aspect : v; // consider aspect\n      geometryRef.current.attributes.position.array[i] = value;\n    });\n    colorsSpring.getValue().forEach((v,i) => {\n      geometryRef.current.attributes.color.array[i] = v;\n    })\n    geometryRef.current.attributes.position.needsUpdate = true;\n    geometryRef.current.attributes.color.needsUpdate = true;\n  });\n\n  useEffect(() => {\n    camera.fov = fov;\n    camera.near = near;\n    camera.far = far;\n    camera.position.set(0, 0, far);\n    camera.updateProjectionMatrix();\n    scene.background = new THREE.Color(0xefefef);\n  }, [ scene, camera ]);\n\n  return (\n    <mesh>\n      <points>\n        <bufferGeometry\n          attach='geometry'\n          ref={geometryRef}\n        >\n          <bufferAttribute\n            attachObject={['attributes', 'position']}\n            count={points.length / 3}\n            array={positionsArray}\n            itemSize={3}\n            usage={THREE.DynamicDrawUsage}\n          />\n          <bufferAttribute\n            attachObject={['attributes', 'color']}\n            count={points.length / 3}\n            array={colorsArray}\n            itemSize={3}\n            usage={THREE.DynamicDrawUsage}\n          />\n        </bufferGeometry>\n        <pointsMaterial\n          attach='material'\n          size={pointsSize}\n          map={sprite}\n          transparent={true}\n          alphaTest={0.5}\n          sizeAttenuation={false}\n          vertexColors={THREE.VertexColors}\n        />\n      </points>\n    </mesh>\n  );\n};\n\nconst App = () => {\n  const [ points, setPoints ] = useState(getRandomPoints());\n  const [ colors, setColors ] = useState(getRandomColors());\n  const [ animatePoints, setAnimatePoints ] = useState(false);\n  const [ animateColors, setAnimateColors ] = useState(false);\n  const [ toogleColorsClass, setToogleColorsClass ] = useState('light');\n  const [ tooglePointsClass, setTooglePointsClass ] = useState('light');\n\n  const tooglePoints = () => {\n    if ( !animatePoints ) {\n      const interval = window.setInterval(() => setPoints(getRandomPoints()), 1000);\n      setAnimatePoints(interval);\n      setTooglePointsClass('dark');\n    } else {\n      clearInterval(animatePoints);\n      setAnimatePoints(false);\n      setTooglePointsClass('light');\n    }\n  };\n\n  const toogleColors = () => {\n    if ( !animateColors ) {\n      const interval = window.setInterval(() => setColors(getRandomColors()), 1000);\n      setAnimateColors(interval);\n      setToogleColorsClass('dark');\n    } else {\n      clearInterval(animateColors);\n      setAnimateColors(false);\n      setToogleColorsClass('light');\n    }\n  };\n\n  return (\n    <div className='canvas-container'>\n      <Canvas>\n        <Scene\n          points={points}\n          colors={colors}\n        />\n      </Canvas>\n      <div className='button-container'>\n        <button\n          type='button'\n          className='btn btn-light'\n          onClick={() => setColors(getRandomColors())}\n        >\n          Change colors\n        </button>\n        <button\n          type='button'\n          className={`btn btn-${toogleColorsClass}`}\n          onClick={() => toogleColors()}\n        >\n          Toogle colors\n        </button>\n        <button\n          type='button'\n          className='btn btn-light'\n          onClick={() => setPoints(getRandomPoints())}\n        >\n          Refresh\n        </button>\n        <button\n          type='button'\n          className={`btn btn-${tooglePointsClass}`}\n          onClick={() => tooglePoints()}\n        >\n          Toogle Refresh\n        </button>\n      </div>\n    </div>\n  )\n};\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}